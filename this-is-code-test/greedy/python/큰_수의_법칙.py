# 큰 수의 법칙

"""
n, m, k를 입력받음.
n은 순서대로 이루어진 배열 내의 개수, m은 반복해서 더 할 총 개수, k는 반복할 수 있는 최대 수

[2, 4, 5, 4, 6]
m: 9, k: 3 -> 6 6 6 5 6 6 6 5 6
m: 8, k: 3 -> 6 6 6 5 6 6 6 5
m: 7, k: 3 -> 6 6 6 5 6 6 6

[6 6 6 5]는 계속 반복이 이루어지고 있음을 확인할 수 있다. 이는 (k + 1)개가 m // (k + 1)번만큼 반복된다는 소리이다.
첫번째 m은 9, k는 3을 보면 9 // (3 + 1)으로 몫은 2, 나머지는 1이다. 이 이야기는 즉슨, 6 6 6 5가 2번 반복하고 6을 한 번 더 더한다는 걸 말한다.
뒤의 반복해서 더하는 숫자는 가장 큰 숫자만 더하기 마련이다. 
"""

n, m, k = map(int, input().split())
arr = list(map(int, input().split()))

arr.sort()
first = arr[len(arr) - 1]
second = arr[len(arr) - 2]

print((first * k + second) * (m // (k + 1)) + first * (m % (k + 1)))